{"id": "What is DSPy according to 400_07_ai-frameworks-dspy.md?", "query": "What is DSPy according to 400_07_ai-frameworks-dspy.md?", "answers": ["a framework for declarative optimization of prompts and programs", "declarative optimization framework for LLM prompts/programs"], "tags": "rag_qa_single"}
{"id": "List the core workflow guides in 000_core.", "query": "List the core workflow guides in 000_core.", "answers": ["000_evaluation-system-entry-point.md, 001_create-prd-TEMPLATE.md, 002_generate-tasks-TEMPLATE.md, 003_process-task-list-TEMPLATE.md", "core workflow guides include evaluation system entry point, PRD creation template, task generation template, and task processing template"], "tags": "rag_qa_single"}
{"id": "According to 400_06_memory-and-context-systems.md, what is the memory system in this project?", "query": "According to 400_06_memory-and-context-systems.md, what is the memory system in this project?", "answers": ["a sophisticated memory context system to maintain state across Cursor AI sessions", "memory context system for maintaining state across AI sessions"], "tags": "rag_qa_single"}
{"id": "why_path_tsv", "query": "Why did we add documents.path_tsv and use ts_rank(..., 32) in retrieval?", "answers": ["To rank by directory semantics with a GIN-indexed tsvector and normalize for length so long prose doesn't dominate."], "tags": "rag_qa_single"}
{"id": "bm25_hints_policy", "query": "Why do we keep BM25 'pure' and put hints only in short/title?", "answers": ["Appending hint bags to BM25 flattens tf-idf and lets generic docs win; short/title hinting boosts precision without distorting BM25."], "tags": "rag_qa_single"}
{"id": "mmr_cap_effect", "query": "What problem do MMR and a per-file cap solve in our retriever?", "answers": ["They prevent one README or single file from monopolizing top-K by rewarding novelty and capping repeats per file."], "tags": "rag_qa_single"}
{"id": "db_adjacent_phrases", "query": "When and why do we use 'create <-> index' and 'alter <-> table' adjacency?", "answers": ["Only for db_workflows to add precise phrase matches that lift SQL artifacts without leaking answers."], "tags": "db_workflows"}
{"id": "filename_microboost", "query": "What is the filename micro-boost and when does it trigger?", "answers": ["A tiny +0.05 prior when the query tokens match the filename; it breaks ties toward the right artifact without overfitting."], "tags": "rag_qa_single"}
{"id": "doc_demote", "query": "Why do we demote docs/design subtrees slightly?", "answers": ["To nudge code/config chunks ahead of long prose in ties; it\u2019s small enough not to harm recall."], "tags": "meta_ops"}
{"id": "vector_ops_selection", "query": "How do we pick the correct vector similarity expression?", "answers": ["We switch by PGVECTOR_OPS: cosine\u21921-(<=>), L2\u21921/(1+<=>), IP\u2192-<=>; keeps semantics correct regardless of index ops."], "tags": "rag_qa_single"}
{"id": "sentence_compaction", "query": "What does the sentence selection step do before the reader?", "answers": ["It scores sentences by token overlap, phrase hits, and filename tokens, then keeps ~10\u201312 best lines to reduce noise and improve precision."], "tags": "rag_qa_single"}
{"id": "ops_bias_subtrees", "query": "Why do we bias ops/shell/setup subtrees for ops_health?", "answers": ["A tiny prior surfaces operational scripts and setup files ahead of generic prose for ops queries."], "tags": "ops_health"}
{"id": "ops_phrase_hints", "query": "Why do ops_health phrase hints include 'health check' and 'shell init'?", "answers": ["They disambiguate shell initialization health tasks from general documentation and concentrate matches on the right scripts."], "tags": "ops_health"}
{"id": "setup_steps_overview", "query": "What are the core steps emphasized under 200_setup?", "answers": ["Model configuration, naming conventions, and setup guides used across the project."], "tags": "rag_qa_single"}
