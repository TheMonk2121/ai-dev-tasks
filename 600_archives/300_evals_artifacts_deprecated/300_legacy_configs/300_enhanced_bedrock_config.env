# Enhanced Bedrock Client Configuration
# Optimized for RAGChecker performance and multi-key load balancing

# =============================================================================
# MULTI-KEY CONFIGURATION
# =============================================================================

# Primary API Key (Key 0)
AWS_ACCESS_KEY_ID=your_primary_access_key_here
AWS_SECRET_ACCESS_KEY=your_primary_secret_key_here
AWS_REGION=us-east-1

# Secondary API Key (Key 1) - Optional, for load balancing
AWS_ACCESS_KEY_ID_1=your_secondary_access_key_here
AWS_SECRET_ACCESS_KEY_1=your_secondary_secret_key_here
AWS_REGION_1=us-west-2

# Tertiary API Key (Key 2) - Optional, for additional throughput
AWS_ACCESS_KEY_ID_2=your_tertiary_access_key_here
AWS_SECRET_ACCESS_KEY_2=your_tertiary_secret_key_here
AWS_REGION_2=eu-west-1

# =============================================================================
# RATE LIMITING OPTIMIZATION
# =============================================================================

# Base rate limit (requests per second) - Conservative starting point
BEDROCK_BASE_RPS=0.5

# Maximum rate limit (requests per second) - Can increase based on performance
BEDROCK_MAX_RPS=2.0

# Maximum concurrent requests in flight
BEDROCK_MAX_IN_FLIGHT=3

# Retry configuration
BEDROCK_MAX_RETRIES=4
BEDROCK_RETRY_BASE=1.8
BEDROCK_RETRY_MAX_SLEEP=20
BEDROCK_OUTER_RETRIES=6

# Cooldown periods (seconds)
BEDROCK_COOLDOWN_SEC=8

# =============================================================================
# RAGCHECKER OPTIMIZATION
# =============================================================================

# Evidence selection and processing
RAGCHECKER_EVIDENCE_KEEP_MODE=target_k
RAGCHECKER_TARGET_K_WEAK=3
RAGCHECKER_TARGET_K_BASE=5
RAGCHECKER_TARGET_K_STRONG=9
RAGCHECKER_SIGNAL_DELTA_WEAK=0.06
RAGCHECKER_SIGNAL_DELTA_STRONG=0.16
RAGCHECKER_EVIDENCE_MAX_SENT=11
RAGCHECKER_EVIDENCE_MIN_SENT=2

# Claim binding and validation
RAGCHECKER_CLAIM_BINDING=1
RAGCHECKER_CLAIM_TOPK=4
RAGCHECKER_DROP_UNSUPPORTED=0
RAGCHECKER_EVIDENCE_MIN_FACT_COVERAGE=0.25

# Multi-signal scoring weights
RAGCHECKER_WEIGHT_JACCARD=0.20
RAGCHECKER_WEIGHT_ROUGE=0.30
RAGCHECKER_WEIGHT_COSINE=0.50
RAGCHECKER_EVIDENCE_JACCARD=0.05
RAGCHECKER_EVIDENCE_COVERAGE=0.16
RAGCHECKER_REDUNDANCY_TRIGRAM_MAX=0.50
RAGCHECKER_PER_CHUNK_CAP=3

# Enhanced retrieval settings
RAGCHECKER_RETRIEVAL_HYBRID=1
RAGCHECKER_USE_RRF=1
RAGCHECKER_USE_MMR=1
RAGCHECKER_MMR_LAMBDA=0.6
RAGCHECKER_CONTEXT_TOPK=20
RAGCHECKER_PER_CASE_SLEEP=0.5

# JSON prompts and coverage rewrite
RAGCHECKER_JSON_PROMPTS=1
RAGCHECKER_COVERAGE_REWRITE=1
RAGCHECKER_TARGET_WORDS=1000
RAGCHECKER_EVIDENCE_GUARD=1

# =============================================================================
# PERFORMANCE MONITORING
# =============================================================================

# Enable detailed logging for debugging
BEDROCK_DEBUG_LOGGING=1

# Usage tracking and cost monitoring
BEDROCK_USAGE_LOGGING=1
BEDROCK_COST_ALERTS=1

# Performance metrics collection
BEDROCK_PERFORMANCE_METRICS=1
BEDROCK_HEALTH_CHECK_INTERVAL=30

# =============================================================================
# FALLBACK AND RESILIENCE
# =============================================================================

# Circuit breaker settings
BEDROCK_CIRCUIT_BREAKER_ENABLED=1
BEDROCK_CIRCUIT_BREAKER_THRESHOLD=3
BEDROCK_CIRCUIT_BREAKER_TIMEOUT=60

# Load balancing preferences
BEDROCK_LOAD_BALANCING_STRATEGY=health_based
BEDROCK_HEALTH_CHECK_ENABLED=1
BEDROCK_AUTO_FAILOVER=1

# =============================================================================
# USAGE NOTES
# =============================================================================

# 1. Copy this file to your project root and rename to .env
# 2. Replace placeholder values with your actual AWS credentials
# 3. For multiple API keys, ensure each has sufficient Bedrock quota
# 4. Monitor usage and adjust rate limits based on performance
# 5. Use AWS CloudWatch to monitor Bedrock API usage and limits

# Expected Performance Improvements:
# - 2-5x faster evaluations through parallel processing
# - More consistent results with fewer retries
# - Better resource utilization across multiple API keys
# - Adaptive rate limiting prevents throttling
# - Health-based load balancing maximizes throughput
